package org.jbehave.scenario.reporters;

import java.io.File;
import java.io.FileReader;
import java.io.FileWriter;
import java.io.FilenameFilter;
import java.io.IOException;
import java.io.Writer;
import java.util.ArrayList;
import java.util.Date;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.Properties;

import org.apache.commons.io.FilenameUtils;
import org.apache.commons.io.IOUtils;

import freemarker.template.Configuration;
import freemarker.template.ObjectWrapper;
import freemarker.template.Template;
import freemarker.template.TemplateException;

/**
 * Freemarker-based report renderer, using the file outputs generated by the
 * reporters for the given format. The templates for each format is injectable
 * via the {@link FreemarkerReportRender(Properties)} constructor. FTL templates
 * are provided by default for index page and for single report rendering. To
 * override, specify the the path the new template under keys "index" and
 * "single".
 * 
 * @author Mauro Talevi
 */
public class FreemarkerReportRenderer implements ReportRenderer {

    private final Configuration configuration;
    private final Properties templateResources;

    public FreemarkerReportRenderer() {
        this(defaultTemplateResources());
    }

    private static Properties defaultTemplateResources() {
        Properties resources = new Properties();
        resources.setProperty("index", "ftl/jbehave-reports-index.ftl");
        resources.setProperty("single", "ftl/jbehave-reports-single.ftl");
        return resources;
    }

    public FreemarkerReportRenderer(Properties templateResources) {
        this.configuration = configure();
        this.templateResources = mergeWithDefault(templateResources);
    }

    private Properties mergeWithDefault(Properties templateResources) {
        Properties resources = defaultTemplateResources();
        resources.putAll(templateResources);
        return resources;
    }

    public void render(File outputDirectory, List<String> formats) {
        createIndex(outputDirectory, formats);
    }

    private void createIndex(File outputDirectory, List<String> formats) {
        String outputName = "rendered/index.html";
        String resource = templateResource("index");
        List<File> reports = reportsFrom(outputDirectory, outputName, formats);
        List<File> renderedReports = renderedReports(reports);
        Map<String, Object> dataModel = newDataModel();
        dataModel.put("reports", renderedReports);
        dataModel.put("publishedDate", new Date());
        write(outputDirectory, outputName, resource, dataModel);
    }

    private List<File> renderedReports(List<File> reports) {
        try {
            String resource = templateResource("single");
            List<File> siteReports = new ArrayList<File>();
            for (File report : reports) {
                String reportName = report.getName();
                String format = formatOf(reportName);
                Map<String, Object> dataModel = newDataModel();
                dataModel.put("name", reportName);
                dataModel.put("body", IOUtils.toString(new FileReader(report)));
                dataModel.put("format", format);
                File outputDirectory = report.getParentFile();
                String outputName = "rendered/" + reportName;
                if ( !format.equals("html") ){
                    outputName = outputName + ".html";
                }
                write(outputDirectory, outputName, resource, dataModel);
                siteReports.add(new File(outputDirectory, outputName));
            }
            return siteReports;
        } catch (Exception e) {
            throw new RuntimeException(e);
        }
    }

    private String formatOf(String reportName) {
        return FilenameUtils.getExtension(reportName);
    }

    private void write(File outputDirectory, String outputName, String resource, Map<String, Object> dataModel) {
        try {
            File file = new File(outputDirectory, outputName);
            file.getParentFile().mkdirs();
            Writer writer = new FileWriter(file);
            process(resource, dataModel, writer);
        } catch (Exception e) {
            throw new RenderingFailedException(resource, e);
        }
    }

    private Configuration configure() {
        Configuration configuration = new Configuration();
        configuration.setClassForTemplateLoading(FreemarkerReportRenderer.class, "/");
        configuration.setObjectWrapper(ObjectWrapper.BEANS_WRAPPER);
        return configuration;
    }

    private void process(String resource, Map<String, Object> dataModel, Writer writer) throws TemplateException,
            IOException {
        Template template = configuration.getTemplate(resource);
        template.process(dataModel, writer);
    }

    private String templateResource(String format) {
        String resource = templateResources.getProperty(format);
        if (resource == null) {
            throw new RendererTemplateNotFoundException(format);
        }
        return resource;
    }

    private Map<String, Object> newDataModel() {
        return new HashMap<String, Object>();
    }

    private List<File> reportsFrom(File outputDirectory, final String outputName, final List<String> formats) {
        List<File> reports = new ArrayList<File>();
        if (outputDirectory == null || !outputDirectory.exists()) {
            return reports;
        }
        String[] reportNames = outputDirectory.list(new FilenameFilter() {
            public boolean accept(File dir, String name) {
                return !name.equals(outputName) && hasFormats(name, formats);
            }

            private boolean hasFormats(String name, List<String> formats) {
                for (String format : formats) {
                    if (name.endsWith(format)) {
                        return true;
                    }
                }
                return false;
            }
        });
        for (String name : reportNames) {
            reports.add(new File(outputDirectory, name));
        }
        return reports;
    }

    @SuppressWarnings("serial")
    public class RenderingFailedException extends RuntimeException {

        public RenderingFailedException(String resource, Exception cause) {
            super("Failed rendering report with resource " + resource, cause);
        }

    }

    @SuppressWarnings("serial")
    public class RendererTemplateNotFoundException extends RuntimeException {

        public RendererTemplateNotFoundException(String format) {
            super("Renderer template not found for format " + format);
        }

    }

}
